<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>–ú–∏–∫—Ä–æ–ø–ª–∞—Ç–µ–∂–∏ v2.3</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f4f7f6;
            color: #333;
        }
        .container {
            max-width: 800px;
            margin: auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(0,0,0,0.1);
        }
        h1, h2 {
            color: #2c3e50;
            text-align: center;
        }
        .controls button {
            padding: 10px 15px;
            font-size: 16px;
            cursor: pointer;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            margin: 5px;
            transition: background-color 0.3s;
        }
        .controls button:hover {
            background-color: #2980b9;
        }
        .status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        .card {
            background: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
        }
        .card h3 {
            margin-top: 0;
            color: #2980b9;
        }
        .card p {
            margin: 5px 0;
        }
        .card strong {
            color: #7f8c8d;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        th, td {
            border: 1px solid #bdc3c7;
            padding: 10px;
            text-align: left;
        }
        th {
            background-color: #3498db;
            color: white;
        }
        tbody tr:nth-child(odd) {
            background-color: #fdfefe;
        }
        tbody tr:nth-child(even) {
            background-color: #f8f9f9;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üí∏ –°–∏—Å—Ç–µ–º–∞ –ú–∏–∫—Ä–æ–ø–ª–∞—Ç–µ–∂–µ–π v2.3</h1>
        <div class="controls" style="text-align: center; margin-bottom: 20px;">
            <button onclick="startSession()">–ù–∞—á–∞—Ç—å —Å–µ—Å—Å–∏—é</button>
            <button onclick="stopSession()">–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Å–µ—Å—Å–∏—é</button>
        </div>

        <div class="status-grid">
            <div class="card">
                <h3>–û–±—â–∏–π –ë–∞–ª–∞–Ω—Å</h3>
                <p><strong>–ë–∞–ª–∞–Ω—Å:</strong> <span id="balance">0.00</span> —Ä—É–±.</p>
            </div>
            <div class="card">
                <h3>–¢–µ–∫—É—â–∏–π –ê–∫—Ç–∏–≤–Ω—ã–π –•–æ–ª–¥</h3>
                <p><strong>–í—Å–µ–≥–æ:</strong> <span id="current_hold_total">-</span> —Ä—É–±.</p>
                <p><strong>–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–æ:</strong> <span id="current_hold_used">-</span> —Ä—É–±.</p>
                <p><strong>–û—Å—Ç–∞—Ç–æ–∫:</strong> <span id="current_hold_remaining">-</span> —Ä—É–±.</p>
            </div>
            <div class="card">
                <h3>–°–ª–µ–¥—É—é—â–∏–π –•–æ–ª–¥</h3>
                <p><strong>–ó–∞—Ä–µ–∑–µ—Ä–≤–∏—Ä–æ–≤–∞–Ω–æ:</strong> <span id="next_hold_total">-</span> —Ä—É–±.</p>
                <p><strong>–û–±—â–µ–µ –æ–±–µ—Å–ø–µ—á–µ–Ω–∏–µ —Ö–æ–ª–¥–∞–º–∏:</strong> <span id="overall_secured">-</span> —Ä—É–±.</p>
            </div>
             <div class="card">
                <h3>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –°–µ—Å—Å–∏–∏</h3>
                <p><strong>–í—Å–µ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–æ –∑–∞ —Å–µ—Å—Å–∏—é:</strong> <span id="total_session_used">0.00</span> —Ä—É–±.</p>
                <p><strong>–î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å —Å–µ—Å—Å–∏–∏:</strong> <span id="session_duration">-</span> —Å–µ–∫.</p>
            </div>
            <div class="card">
                <h3>–ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å</h3>
                <p><strong>–°—Ä–µ–¥–Ω–µ–µ –≤—Ä–µ–º—è –∑–∞–ø—Ä–æ—Å–∞ —Ö–æ–ª–¥–∞:</strong> <span id="avg_hold_time">-</span> –º—Å.</p>
                <p><strong>–°—Ä–µ–¥–Ω–µ–µ –≤—Ä–µ–º—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –ø–ª–∞—Ç–µ–∂–∞:</strong> <span id="avg_payment_time">-</span> –º—Å.</p>
            </div>
        </div>

        <h2>‚è±Ô∏è –ò—Å—Ç–æ—Ä–∏—è –û–ø–µ—Ä–∞—Ü–∏–π –•–æ–ª–¥–∞</h2>
        <table>
            <thead>
                <tr>
                    <th>–ù–∞—á–∞–ª–æ</th>
                    <th>–ö–æ–Ω–µ—Ü</th>
                    <th>–°—Ç–∞—Ç—É—Å</th>
                    <th>–í—Ä–µ–º—è (–º—Å)</th>
                </tr>
            </thead>
            <tbody id="hold_history_table_body"></tbody>
        </table>
    </div>

    <script>
        const animationStepTime = 50; // ms for animation interval
        const statusPollTime = 200;    // ms for polling /status
        const precision = 0.01;

        let animators = {
            total_session_used: { current: 0.00, target: 0.00, intervalId: null, elementId: 'total_session_used', initialized: false },
            balance: { current: 0.00, target: 0.00, intervalId: null, elementId: 'balance', initialized: false }
        };
        let globalIsSessionActive = false;
        let statusPollIntervalId = null;

        function getAuthHeaders() {
            return {
                'Authorization': 'Basic ' + btoa("admin:securepassword123")
            };
        }

        function runAnimationStep(animatorKey) {
            const animator = animators[animatorKey];
            
            if (!globalIsSessionActive || Math.abs(animator.current - animator.target) < precision) {
                animator.current = animator.target;
                if (animator.intervalId) {
                    clearInterval(animator.intervalId);
                    animator.intervalId = null;
                }
            } else {
                let diff = animator.target - animator.current;
                let step = diff * 0.15; // Slightly faster animation
                if (Math.abs(step) < precision && Math.abs(diff) >= precision) {
                    step = precision * Math.sign(diff);
                }
                animator.current += step;
            }
            document.getElementById(animator.elementId).textContent = animator.current.toFixed(2);
        }

        async function fetchStatus() {
            try {
                const res = await fetch('/status', { headers: getAuthHeaders() });
                if (!res.ok) {
                    console.error("Failed to fetch status:", res.status);
                    return;
                }
                const data = await res.json();
                globalIsSessionActive = data.is_session_active;

                // Update targets for animated values
                animators.total_session_used.target = data.total_session_used;
                animators.balance.target = data.balance;

                // Initialize if not yet done (e.g., on page load)
                if (!animators.total_session_used.initialized) {
                    animators.total_session_used.current = data.total_session_used;
                    document.getElementById(animators.total_session_used.elementId).textContent = animators.total_session_used.current.toFixed(2);
                    animators.total_session_used.initialized = true;
                }
                if (!animators.balance.initialized) {
                    animators.balance.current = data.balance;
                    document.getElementById(animators.balance.elementId).textContent = animators.balance.current.toFixed(2);
                    animators.balance.initialized = true;
                }

                // Manage animations based on session state
                for (const key in animators) {
                    const animator = animators[key];
                    if (globalIsSessionActive) {
                        if (!animator.intervalId && animator.initialized) {
                            animator.intervalId = setInterval(() => runAnimationStep(key), animationStepTime);
                        }
                    } else {
                        if (animator.intervalId) {
                            clearInterval(animator.intervalId);
                            animator.intervalId = null;
                        }
                        // Ensure final value is set when session is not active
                        animator.current = animator.target;
                        document.getElementById(animator.elementId).textContent = animator.current.toFixed(2);
                    }
                }

                // Update non-animated fields
                document.getElementById('current_hold_total').textContent = data.current_active_hold.total.toFixed(2);
                document.getElementById('current_hold_used').textContent = data.current_active_hold.used.toFixed(2);
                document.getElementById('current_hold_remaining').textContent = data.current_active_hold.remaining.toFixed(2);
                document.getElementById('next_hold_total').textContent = data.next_pending_hold.toFixed(2);
                document.getElementById('overall_secured').textContent = data.overall_secured_by_holds.toFixed(2);
                document.getElementById('session_duration').textContent = data.session_duration_seconds.toFixed(2);
                document.getElementById('avg_hold_time').textContent = data.avg_hold_request_time_ms.toFixed(2);
                document.getElementById('avg_payment_time').textContent = data.avg_payment_time_ms.toFixed(2);

                const historyTableBody = document.getElementById('hold_history_table_body');
                historyTableBody.innerHTML = ""; 
                if (data.hold_requests_history && data.hold_requests_history.length > 0) {
                    data.hold_requests_history.forEach(req => {
                        const row = historyTableBody.insertRow();
                        row.insertCell().textContent = new Date(req.start_time_str).toLocaleString();
                        row.insertCell().textContent = new Date(req.end_time_str).toLocaleString();
                        row.insertCell().textContent = req.status;
                        row.insertCell().textContent = req.duration_ms ? req.duration_ms.toFixed(2) : "N/A";
                    });
                } else {
                    const row = historyTableBody.insertRow();
                    const cell = row.insertCell();
                    cell.colSpan = 4;
                    cell.textContent = "–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –ø–æ –æ–ø–µ—Ä–∞—Ü–∏—è–º —Ö–æ–ª–¥–∞.";
                    cell.style.textAlign = "center";
                }

            } catch (error) {
                console.error("Error fetching or processing status:", error);
            }
        }

        async function startSession() {
            try {
                await fetch('/start', { method: 'POST', headers: getAuthHeaders() });
                console.log("Session start requested.");
                
                // Reset total_session_used for new session
                animators.total_session_used.current = 0.00;
                animators.total_session_used.target = 0.00;
                animators.total_session_used.initialized = true; 
                document.getElementById(animators.total_session_used.elementId).textContent = "0.00";

                // Balance will be initialized by the first fetchStatus call after session start
                animators.balance.initialized = false; 

                // Clear any old animation intervals
                for (const key in animators) {
                    if (animators[key].intervalId) clearInterval(animators[key].intervalId);
                    animators[key].intervalId = null;
                }
                globalIsSessionActive = true; // Tentatively set, fetchStatus will confirm
                fetchStatus(); // Fetch status immediately to update UI and start animations
            } catch (error) {
                console.error("Error starting session:", error);
            }
        }

        async function stopSession() {
            try {
                await fetch('/stop', { method: 'POST', headers: getAuthHeaders() });
                console.log("Session stop requested.");
                globalIsSessionActive = false; // Tentatively set, fetchStatus will confirm and stop animations
                fetchStatus(); // Fetch status immediately to update UI and stop animations
            } catch (error) {
                console.error("Error stopping session:", error);
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('total_session_used').textContent = "0.00";
            document.getElementById('balance').textContent = "---.--"; // Initial placeholder
            fetchStatus(); // Initial fetch
            if (statusPollIntervalId) clearInterval(statusPollIntervalId);
            statusPollIntervalId = setInterval(fetchStatus, statusPollTime); // Start polling
        });

    </script>
</body>
</html>
